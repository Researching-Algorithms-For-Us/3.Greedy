
# Greedy (탐욕 알고리즘)

  
탐욕적 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고,

각 단계마다, 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나, 동적 계획법 알고리즘과 크게 다를것이 없음. 하지만, 모든 선택지를 고려 하는 두 알고리즘과 달리,

***탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택하는 알고리즘***

## 그리디 알고리즘 설계 절차
1. 선정과정 (Selection Procedure)
   1. 재 상태에서 가장 좋은 선택이라고 생각되는 해답을 찾아서 해답모음(solution set)에 포함시킨다.
2. 적정성 검사(Feasibility Test)
   1. 새로 얻은 해답모음이 적절한지를 결정한다.
3. 해답 검사(Solution Check) 
   1. 새로 얻은 해답모음이 최적의 해인지 결정한다. 

## 대표적인 알고리즘
+ 거스름돈 문제
+ 최소비용 신장트리 
  + Prim 알고리즘
  + Kruskal 알고리즘
+ 다익스트라 알고리즘
+ 배낭 문제
  + 0-1 배낭 채우기 문제
+ 최적 머지 패턴
+ 허프만 코드 ( 최적 이진 코드 )

## 외판원 문제

동적 계획법으로 접근했을땐, 도착할수있는 도시들을 하나하나 검사하고 남은 도시를 순회하여, 
필요한 거리가 최소인 답을 찾지만, 탐욕 알고리즘은 지금 당장 가장 가까운 도시만 찾아간다.
  

## 정리

1. 탐욕법을 사용해도 항상 최적해를 구할수 있는 문제를 만난 경우, 탐욕법은 동적 계획법 보다, 훨씬 빠르게 해를 찾음.

2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면, 최적해 대신, 근사해를 찾는 것으로 타협할 수 있음.

> 프로그래밍 대회에서는 보통 첫 번째 용도로만 사용됨, 근사해를 찾는 문제는 대개 출제되지 않으며, 가끔 근사해를 구하는 문제가 나왓다 하더라도, 조합 탐색이나, 메타휴리스틱 알고리즘들이 더 좋은 답을 주는 경우가 있음.

탐욕법의 개념은 간단하지만, 제일 발목을 잡는 토픽중 하나임.
어느 방법을 선택해야 최적해를 구할수 있는지 판단기준이 애매하기 때문.

탐욕적 알고리즘은 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋음.
 
